{
  "version": 3,
  "sources": ["../lib/assign.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nvar shape2strides = require( '@stdlib/ndarray-base-shape2strides' );\nvar vind2bind = require( '@stdlib/ndarray-base-vind2bind' );\nvar numel = require( '@stdlib/ndarray-base-numel' );\nvar grev = require( '@stdlib/blas-ext-base-grev' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar copy = require( '@stdlib/array-base-copy-indexed' );\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// FUNCTIONS //\n\n/**\n* Copies a specified number of array elements to a provided array according to a callback function.\n*\n* @private\n* @param {Array} x - input array\n* @param {NonNegativeInteger} N - number of elements to copy\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback execution context\n*\n* @example\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ 1, 2, 3, 4 ];\n*\n* var out = [ 0, 0, 0 ];\n* copyBy( x, 3, out, 1, 0, scale );\n*\n* var o = out;\n* // returns [ 2, 4, 6 ]\n*/\nfunction copyBy( x, N, out, stride, offset, clbk, thisArg ) {\n\tvar i;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tout[ offset ] = clbk.call( thisArg, x[ i ], [ i ], x );\n\t\toffset += stride;\n\t}\n}\n\n/**\n* Recursively flattens an array in lexicographic order.\n*\n* @private\n* @param {Array} orig - original input array\n* @param {Array} x - array to flatten\n* @param {NonNegativeInteger} ndims - number of dimensions in the input array\n* @param {NonNegativeIntegerArray} shape - shape of the input array\n* @param {NonNegativeInteger} dim - dimension index\n* @param {NonNegativeIntegerArray} indices - outer array element indices\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback execution context\n* @returns {NonNegativeInteger} offset for next output array element\n*/\nfunction recurseLexicographic( orig, x, ndims, shape, dim, indices, out, stride, offset, clbk, thisArg ) { // eslint-disable-line max-params\n\tvar FLG;\n\tvar idx;\n\tvar S;\n\tvar d;\n\tvar i;\n\n\t// Check whether we've reached the last dimension:\n\td = dim + 1;\n\tFLG = ( d === ndims );\n\n\tS = shape[ dim ];\n\tfor ( i = 0; i < S; i++ ) {\n\t\tidx = indices.slice();\n\t\tidx.push( i );\n\t\tif ( FLG ) {\n\t\t\tout[ offset ] = clbk.call( thisArg, x[ i ], idx, orig );\n\t\t\toffset += stride;\n\t\t} else {\n\t\t\toffset = recurseLexicographic( orig, x[ i ], ndims, shape, d, idx, out, stride, offset, clbk, thisArg );\n\t\t}\n\t}\n\treturn offset;\n}\n\n/**\n* Flattens an array in colexicographic order.\n*\n* @private\n* @param {Array} x - array to flatten\n* @param {NonNegativeInteger} ndims - number of dimensions in the input array\n* @param {NonNegativeIntegerArray} shape - shape of the input array\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback execution context\n*/\nfunction flattenColexicographic( x, ndims, shape, out, stride, offset, clbk, thisArg ) {\n\tvar len;\n\tvar tmp;\n\tvar ord;\n\tvar sh;\n\tvar sx;\n\tvar j;\n\tvar i;\n\n\t// Note that, in contrast to lexicographic iteration, we cannot readily define a straightforward recursive definition for colexicographic iteration. Accordingly, we have to perform a workaround in which we first flatten in lexicographic order and then perform an out-of-place transposition to return an array in colexicographic order.\n\n\t// Determine how many elements will be in the output array:\n\tlen = numel( shape );\n\n\t// For input arrays having an arbitrary number of dimensions, first flatten in lexicographic order:\n\ttmp = zeros( len );\n\trecurseLexicographic( x, x, ndims, shape, 0, [], tmp, 1, 0, clbk, thisArg );\n\n\t// Define the memory layout:\n\tord = 'row-major';\n\n\t// Generate a stride array for lexicographic order:\n\tsx = shape2strides( shape, ord );\n\n\t// Reverse the dimensions and strides (i.e., define the shape and strides of the transpose):\n\tsh = copy( shape );\n\tgrev( ndims, sh, 1 );\n\tgrev( ndims, sx, 1 );\n\n\t// Iterate over each element based on the linear **view** index (note: this has negative performance implications due to lack of data locality)...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tj = vind2bind( sh, sx, 0, ord, i, MODE );\n\t\tout[ offset ] = tmp[ j ];\n\t\toffset += stride;\n\t}\n}\n\n\n// MAIN //\n\n/**\n* Flattens an n-dimensional nested array according to a callback function and assigns elements to a provided output array.\n*\n* ## Notes\n*\n* -   The function assumes that all nested arrays have the same length (i.e., the input array is **not** a ragged array).\n*\n* @param {Array} x - input nested array\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {boolean} colexicographic - specifies whether to flatten array values in colexicographic order\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array index offset\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback execution context\n* @returns {Collection} output array\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flattenBy( x, [ 2, 2 ], false, new Float64Array( 4 ), 1, 0, scale );\n* // returns <Float64Array>[ 2, 4, 6, 8 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flattenBy( x, [ 2, 2 ], true, new Float64Array( 4 ), 1, 0, scale );\n* // returns <Float64Array>[ 2, 6, 4, 8 ]\n*/\nfunction flattenBy( x, shape, colexicographic, out, stride, offset, clbk, thisArg ) {\n\tvar ndims = shape.length;\n\tif ( ndims === 0 ) { // 0-dimensional array\n\t\treturn out;\n\t}\n\tif ( ndims === 1 ) { // 1-dimensional array\n\t\t// For 1-dimensional arrays, we can perform simple iteration:\n\t\tcopyBy( x, shape[ 0 ], out, stride, offset, clbk, thisArg );\n\t\treturn out;\n\t}\n\tif ( colexicographic ) {\n\t\tflattenColexicographic( x, ndims, shape, out, stride, offset, clbk, thisArg );\n\t\treturn out;\n\t}\n\trecurseLexicographic( x, x, ndims, shape, 0, [], out, stride, offset, clbk, thisArg );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = flattenBy;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar numel = require( '@stdlib/ndarray-base-numel' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar assign = require( './assign.js' );\n\n\n// MAIN //\n\n/**\n* Flattens an n-dimensional nested array according to a callback function.\n*\n* ## Notes\n*\n* -   The function assumes that all nested arrays have the same length (i.e., the input array is **not** a ragged array).\n*\n* @param {Array} x - input nested array\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {boolean} colexicographic - specifies whether to flatten array values in colexicographic order\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback execution context\n* @returns {Array} flattened array\n*\n* @example\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flattenBy( x, [ 2, 2 ], false, scale );\n* // returns [ 2, 4, 6, 8 ]\n*\n* @example\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flattenBy( x, [ 2, 2 ], true, scale );\n* // returns [ 2, 6, 4, 8 ]\n*/\nfunction flattenBy( x, shape, colexicographic, clbk, thisArg ) {\n\tvar out = zeros( numel( shape ) );\n\treturn assign( x, shape, colexicographic, out, 1, 0, clbk, thisArg );\n}\n\n\n// EXPORTS //\n\nmodule.exports = flattenBy;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Flatten an n-dimensional nested array according to a callback function.\n*\n* @module @stdlib/array-base-flatten-by\n*\n* @example\n* var flattenBy = require( '@stdlib/array-base-flatten-by' );\n*\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flattenBy( x, [ 2, 2 ], false, scale );\n* // returns [ 2, 4, 6, 8 ]\n*\n* @example\n* var flattenBy = require( '@stdlib/array-base-flatten-by' );\n*\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flattenBy( x, [ 2, 2 ], true, scale );\n* // returns [ 2, 6, 4, 8 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var flattenBy = require( '@stdlib/array-base-flatten-by' );\n*\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = new Float64Array( 4 );\n* var y = flattenBy.assign( x, [ 2, 2 ], true, out, 1, 0, scale );\n* // returns <Float64Array>[ 2, 6, 4, 8 ]\n*\n* var bool = ( y === out );\n* // returns true\n*/\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar main = require( './main.js' );\nvar assign = require( './assign.js' );\n\n\n// MAIN //\n\nsetReadOnly( main, 'assign', assign );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_assign", "__commonJSMin", "exports", "module", "shape2strides", "vind2bind", "numel", "grev", "zeros", "copy", "MODE", "copyBy", "x", "N", "out", "stride", "offset", "clbk", "thisArg", "recurseLexicographic", "orig", "ndims", "shape", "dim", "indices", "FLG", "idx", "S", "d", "i", "flattenColexicographic", "len", "tmp", "ord", "sh", "sx", "j", "flattenBy", "colexicographic", "require_main", "__commonJSMin", "exports", "module", "numel", "zeros", "assign", "flattenBy", "x", "shape", "colexicographic", "clbk", "thisArg", "out", "setReadOnly", "main", "assign"]
}
