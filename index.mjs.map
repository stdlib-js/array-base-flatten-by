{"version":3,"file":"index.mjs","sources":["../lib/assign.js","../lib/main.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport shape2strides from '@stdlib/ndarray-base-shape2strides';\nimport vind2bind from '@stdlib/ndarray-base-vind2bind';\nimport numel from '@stdlib/ndarray-base-numel';\nimport grev from '@stdlib/blas-ext-base-grev';\nimport zeros from '@stdlib/array-base-zeros';\nimport copy from '@stdlib/array-base-copy-indexed';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// FUNCTIONS //\n\n/**\n* Copies a specified number of array elements to a provided array according to a callback function.\n*\n* @private\n* @param {Array} x - input array\n* @param {NonNegativeInteger} N - number of elements to copy\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback execution context\n*\n* @example\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ 1, 2, 3, 4 ];\n*\n* var out = [ 0, 0, 0 ];\n* copyBy( x, 3, out, 1, 0, scale );\n*\n* var o = out;\n* // returns [ 2, 4, 6 ]\n*/\nfunction copyBy( x, N, out, stride, offset, clbk, thisArg ) {\n\tvar i;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tout[ offset ] = clbk.call( thisArg, x[ i ], [ i ], x );\n\t\toffset += stride;\n\t}\n}\n\n/**\n* Recursively flattens an array in lexicographic order.\n*\n* @private\n* @param {Array} orig - original input array\n* @param {Array} x - array to flatten\n* @param {NonNegativeInteger} ndims - number of dimensions in the input array\n* @param {NonNegativeIntegerArray} shape - shape of the input array\n* @param {NonNegativeInteger} dim - dimension index\n* @param {NonNegativeIntegerArray} indices - outer array element indices\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback execution context\n* @returns {NonNegativeInteger} offset for next output array element\n*/\nfunction recurseLexicographic( orig, x, ndims, shape, dim, indices, out, stride, offset, clbk, thisArg ) { // eslint-disable-line max-params\n\tvar FLG;\n\tvar idx;\n\tvar S;\n\tvar d;\n\tvar i;\n\n\t// Check whether we've reached the last dimension:\n\td = dim + 1;\n\tFLG = ( d === ndims );\n\n\tS = shape[ dim ];\n\tfor ( i = 0; i < S; i++ ) {\n\t\tidx = indices.slice(); // we explicitly copy in order to avoid potential mutation when calling `clbk`\n\t\tidx.push( i );\n\t\tif ( FLG ) {\n\t\t\tout[ offset ] = clbk.call( thisArg, x[ i ], idx, orig );\n\t\t\toffset += stride;\n\t\t} else {\n\t\t\toffset = recurseLexicographic( orig, x[ i ], ndims, shape, d, idx, out, stride, offset, clbk, thisArg );\n\t\t}\n\t}\n\treturn offset;\n}\n\n/**\n* Flattens an array in colexicographic order.\n*\n* @private\n* @param {Array} x - array to flatten\n* @param {NonNegativeInteger} ndims - number of dimensions in the input array\n* @param {NonNegativeIntegerArray} shape - shape of the input array\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback execution context\n*/\nfunction flattenColexicographic( x, ndims, shape, out, stride, offset, clbk, thisArg ) {\n\tvar len;\n\tvar tmp;\n\tvar ord;\n\tvar sh;\n\tvar sx;\n\tvar j;\n\tvar i;\n\n\t// Note that, in contrast to lexicographic iteration, we cannot readily define a straightforward recursive definition for colexicographic iteration. Accordingly, we have to perform a workaround in which we first flatten in lexicographic order and then perform an out-of-place transposition to return an array in colexicographic order.\n\n\t// Determine how many elements will be in the output array:\n\tlen = numel( shape );\n\n\t// For input arrays having an arbitrary number of dimensions, first flatten in lexicographic order:\n\ttmp = zeros( len );\n\trecurseLexicographic( x, x, ndims, shape, 0, [], tmp, 1, 0, clbk, thisArg );\n\n\t// Define the memory layout:\n\tord = 'row-major';\n\n\t// Generate a stride array for lexicographic order:\n\tsx = shape2strides( shape, ord );\n\n\t// Reverse the dimensions and strides (i.e., define the shape and strides of the transpose):\n\tsh = copy( shape );\n\tgrev( ndims, sh, 1 );\n\tgrev( ndims, sx, 1 );\n\n\t// Iterate over each element based on the linear **view** index (note: this has negative performance implications due to lack of data locality)...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tj = vind2bind( sh, sx, 0, ord, i, MODE );\n\t\tout[ offset ] = tmp[ j ];\n\t\toffset += stride;\n\t}\n}\n\n\n// MAIN //\n\n/**\n* Flattens an n-dimensional nested array according to a callback function and assigns elements to a provided output array.\n*\n* ## Notes\n*\n* -   The function assumes that all nested arrays have the same length (i.e., the input array is **not** a ragged array).\n*\n* @param {Array} x - input nested array\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {boolean} colexicographic - specifies whether to flatten array values in colexicographic order\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array index offset\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback execution context\n* @returns {Collection} output array\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flattenBy( x, [ 2, 2 ], false, new Float64Array( 4 ), 1, 0, scale );\n* // returns <Float64Array>[ 2, 4, 6, 8 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flattenBy( x, [ 2, 2 ], true, new Float64Array( 4 ), 1, 0, scale );\n* // returns <Float64Array>[ 2, 6, 4, 8 ]\n*/\nfunction flattenBy( x, shape, colexicographic, out, stride, offset, clbk, thisArg ) {\n\tvar ndims = shape.length;\n\tif ( ndims === 0 ) { // 0-dimensional array\n\t\treturn out;\n\t}\n\tif ( ndims === 1 ) { // 1-dimensional array\n\t\t// For 1-dimensional arrays, we can perform simple iteration:\n\t\tcopyBy( x, shape[ 0 ], out, stride, offset, clbk, thisArg );\n\t\treturn out;\n\t}\n\tif ( colexicographic ) {\n\t\tflattenColexicographic( x, ndims, shape, out, stride, offset, clbk, thisArg );\n\t\treturn out;\n\t}\n\trecurseLexicographic( x, x, ndims, shape, 0, [], out, stride, offset, clbk, thisArg );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default flattenBy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport numel from '@stdlib/ndarray-base-numel';\nimport zeros from '@stdlib/array-base-zeros';\nimport assign from './assign.js';\n\n\n// MAIN //\n\n/**\n* Flattens an n-dimensional nested array according to a callback function.\n*\n* ## Notes\n*\n* -   The function assumes that all nested arrays have the same length (i.e., the input array is **not** a ragged array).\n*\n* @param {Array} x - input nested array\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {boolean} colexicographic - specifies whether to flatten array values in colexicographic order\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback execution context\n* @returns {Array} flattened array\n*\n* @example\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flattenBy( x, [ 2, 2 ], false, scale );\n* // returns [ 2, 4, 6, 8 ]\n*\n* @example\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flattenBy( x, [ 2, 2 ], true, scale );\n* // returns [ 2, 6, 4, 8 ]\n*/\nfunction flattenBy( x, shape, colexicographic, clbk, thisArg ) {\n\tvar out = zeros( numel( shape ) );\n\treturn assign( x, shape, colexicographic, out, 1, 0, clbk, thisArg );\n}\n\n\n// EXPORTS //\n\nexport default flattenBy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Flatten an n-dimensional nested array according to a callback function.\n*\n* @module @stdlib/array-base-flatten-by\n*\n* @example\n* import flattenBy from '@stdlib/array-base-flatten-by';\n*\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flattenBy( x, [ 2, 2 ], false, scale );\n* // returns [ 2, 4, 6, 8 ]\n*\n* @example\n* import flattenBy from '@stdlib/array-base-flatten-by';\n*\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flattenBy( x, [ 2, 2 ], true, scale );\n* // returns [ 2, 6, 4, 8 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import flattenBy from '@stdlib/array-base-flatten-by';\n*\n* function scale( v ) {\n*     return v * 2;\n* }\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = new Float64Array( 4 );\n* var y = flattenBy.assign( x, [ 2, 2 ], true, out, 1, 0, scale );\n* // returns <Float64Array>[ 2, 6, 4, 8 ]\n*\n* var bool = ( y === out );\n* // returns true\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport main from './main.js';\nimport assign from './assign.js';\n\n\n// MAIN //\n\nsetReadOnly( main, 'assign', assign );\n\n\n// EXPORTS //\n\nexport default main;\n"],"names":["MODE","recurseLexicographic","orig","x","ndims","shape","dim","indices","out","stride","offset","clbk","thisArg","FLG","idx","S","d","i","slice","push","call","flattenBy","colexicographic","length","N","copyBy","len","tmp","ord","sh","sx","j","numel","zeros","shape2strides","copy","grev","vind2bind","flattenColexicographic","assign","setReadOnly","main"],"mappings":";;qrBAkCA,IAAIA,EAAO,QAuDX,SAASC,EAAsBC,EAAMC,EAAGC,EAAOC,EAAOC,EAAKC,EAASC,EAAKC,EAAQC,EAAQC,EAAMC,GAC9F,IAAIC,EACAC,EACAC,EACAC,EACAC,EAOJ,IAHAJ,GADAG,EAAIV,EAAM,KACIF,EAEdW,EAAIV,EAAOC,GACLW,EAAI,EAAGA,EAAIF,EAAGE,KACnBH,EAAMP,EAAQW,SACVC,KAAMF,GACLJ,GACJL,EAAKE,GAAWC,EAAKS,KAAMR,EAAST,EAAGc,GAAKH,EAAKZ,GACjDQ,GAAUD,GAEVC,EAAST,EAAsBC,EAAMC,EAAGc,GAAKb,EAAOC,EAAOW,EAAGF,EAAKN,EAAKC,EAAQC,EAAQC,EAAMC,GAGhG,OAAOF,CACR,CAgGA,SAASW,EAAWlB,EAAGE,EAAOiB,EAAiBd,EAAKC,EAAQC,EAAQC,EAAMC,GACzE,IAAIR,EAAQC,EAAMkB,OAClB,OAAe,IAAVnB,EACGI,EAEO,IAAVJ,GArJN,SAAiBD,EAAGqB,EAAGhB,EAAKC,EAAQC,EAAQC,EAAMC,GACjD,IAAIK,EACJ,IAAMA,EAAI,EAAGA,EAAIO,EAAGP,IACnBT,EAAKE,GAAWC,EAAKS,KAAMR,EAAST,EAAGc,GAAK,CAAEA,GAAKd,GACnDO,GAAUD,CAEZ,CAiJEgB,CAAQtB,EAAGE,EAAO,GAAKG,EAAKC,EAAQC,EAAQC,EAAMC,GAC3CJ,GAEHc,GA3FN,SAAiCnB,EAAGC,EAAOC,EAAOG,EAAKC,EAAQC,EAAQC,EAAMC,GAC5E,IAAIc,EACAC,EACAC,EACAC,EACAC,EACAC,EACAd,EAuBJ,IAlBAS,EAAMM,EAAO3B,GAIbJ,EAAsBE,EAAGA,EAAGC,EAAOC,EAAO,EAAG,GAD7CsB,EAAMM,EAAOP,GACyC,EAAG,EAAGf,EAAMC,GAMlEkB,EAAKI,EAAe7B,EAHpBuB,EAAM,aAMNC,EAAKM,EAAM9B,GACX+B,EAAMhC,EAAOyB,EAAI,GACjBO,EAAMhC,EAAO0B,EAAI,GAGXb,EAAI,EAAGA,EAAIS,EAAKT,IACrBc,EAAIM,EAAWR,EAAIC,EAAI,EAAGF,EAAKX,EAAGjB,GAClCQ,EAAKE,GAAWiB,EAAKI,GACrBrB,GAAUD,CAEZ,CAyDE6B,CAAwBnC,EAAGC,EAAOC,EAAOG,EAAKC,EAAQC,EAAQC,EAAMC,GAC7DJ,IAERP,EAAsBE,EAAGA,EAAGC,EAAOC,EAAO,EAAG,GAAIG,EAAKC,EAAQC,EAAQC,EAAMC,GACrEJ,EACR,CCjKA,SAASa,EAAWlB,EAAGE,EAAOiB,EAAiBX,EAAMC,GAEpD,OAAO2B,EAAQpC,EAAGE,EAAOiB,EADfW,EAAOD,EAAO3B,IACuB,EAAG,EAAGM,EAAMC,EAC5D,CCUA4B,EAAAC,EAAA,SAAAF"}